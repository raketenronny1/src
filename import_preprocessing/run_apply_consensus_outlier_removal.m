% run_apply_consensus_outlier_removal.m
%
% PURPOSE:
%   Applies a consensus (T2 AND Q) outlier removal strategy to the training
%   dataset. It loads the T2/Q statistics and thresholds calculated by
%   run_exploratory_outlier_analysis.m and generates the cleaned datasets.
%
% INPUTS:
%   - dataTableTrain.mat: Original training data table with probe-level info.
%                         'CombinedSpectra' should hold the preprocessed spectra
%                         that were used for the T2/Q analysis.
%   - *_ExploratoryOutlier_AnalysisData.mat: File generated by
%     run_exploratory_outlier_analysis.m, containing T2/Q values, thresholds,
%     mappings, and PCA model for ALL training spectra.
%   - wavenumbers_roi.mat: Wavenumber vector.
%
% OUTPUTS:
%   - YYYYMMDD_training_set_no_outliers_T2andQ.mat: Cleaned flat dataset.
%   - YYYYMMDD_dataTableTrain_Cleaned_Consensus_T2andQ.mat: Cleaned table.
%   - YYYYMMDD_PCA_T2andQ_Consensus_RemovedOutlierList.csv: List of removed outliers.
%
% DATE: 2025-05-17

%% --- 0. Configuration & Setup ---
clear; clc; close all;
fprintf('Applying Consensus (T2 AND Q) Outlier Removal - %s\n', string(datetime('now')));

projectBasePath = pwd; % Assumes script is run from project root
dataPath    = fullfile(projectBasePath, 'data');
% Results from this script are the cleaned datasets
resultsDir = fullfile(projectBasePath, 'results'); % Main results for cleaned data
exploratoryResultsDir = fullfile(projectBasePath, 'results', 'Phase1_OutlierExploration'); % Where exploratory .mat is saved

P.datePrefix = string(datetime('now','Format','yyyyMMdd')); % For output filenames

%% --- 1. Load Necessary Data ---
fprintf('\n--- 1. Loading Input Data ---\n');

% Load original dataTableTrain
trainDataTableFile = fullfile(dataPath, 'data_table_train.mat');
if ~exist(trainDataTableFile, 'file'), error('File %s not found.', trainDataTableFile); end
fprintf('Loading original dataTableTrain from: %s\n', trainDataTableFile);
loadedVars = load(trainDataTableFile);
if ~isfield(loadedVars, 'dataTableTrain'), error('Var "dataTableTrain" not found in %s.', trainDataTableFile); end
dataTableTrain_original = loadedVars.dataTableTrain; % Use a distinct name
fprintf('Original dataTableTrain loaded with %d probes.\n', height(dataTableTrain_original));

% Load wavenumbers
if ~exist('wavenumbers_roi', 'var') % Check if already in workspace from a previous run
    try
        wavenumbers_data_loaded = load(fullfile(dataPath, 'wavenumbers.mat'), 'wavenumbers_roi');
        wavenumbers_roi = wavenumbers_data_loaded.wavenumbers_roi;
        if iscolumn(wavenumbers_roi), wavenumbers_roi = wavenumbers_roi'; end
    catch ME_wave, error('Error loading wavenumbers.mat: %s', ME_wave.message); end
end
fprintf('wavenumbers_roi available (%d points).\n', length(wavenumbers_roi));
num_wavenumber_points = length(wavenumbers_roi);

% Load the Exploratory Outlier Analysis Data
exploratoryFiles = dir(fullfile(exploratoryResultsDir, '*_ExploratoryOutlier_AnalysisData.mat'));
if isempty(exploratoryFiles)
    error('No "*_ExploratoryOutlier_AnalysisData.mat" file found in %s. Run exploratory script first.', exploratoryResultsDir);
end
[~,idxSortExploratory] = sort([exploratoryFiles.datenum],'descend');
latestExploratoryFile = fullfile(exploratoryResultsDir, exploratoryFiles(idxSortExploratory(1)).name);
fprintf('Loading exploratory outlier analysis data from: %s\n', latestExploratoryFile);
loadedExploratoryData = load(latestExploratoryFile, 'exploratoryOutlierData');
if ~isfield(loadedExploratoryData, 'exploratoryOutlierData')
    error('Variable "exploratoryOutlierData" not found in %s.', latestExploratoryFile);
end
expData = loadedExploratoryData.exploratoryOutlierData;
fprintf('Exploratory data loaded. Alpha used: %.3f, k_model: %d\n', expData.alpha_T2_Q, expData.k_model);

% Extract necessary variables from expData
T2_values_all                   = expData.T2_values_all_spectra;
Q_values_all                    = expData.Q_values_all_spectra;
T2_threshold                    = expData.T2_threshold;
Q_threshold                     = expData.Q_threshold;
Original_ProbeRowIndices_map    = expData.Original_ProbeRowIndices_map;
Original_SpectrumIndexInProbe_map = expData.Original_SpectrumIndexInProbe_map;
Patient_ID_map                  = expData.Patient_ID_map;
y_numeric_map                   = expData.y_numeric_map;
y_categorical_map               = expData.y_categorical_map;

% Reconstruct X_train from the original dataTableTrain, ensuring order matches T2/Q values
% This step is crucial for correct mapping.
X_train_for_removal = [];
temp_row_counter = 0;
for i = 1:height(dataTableTrain_original)
    spectraMatrix = dataTableTrain_original.CombinedSpectra{i}; % Should be the same spectra used for T2/Q analysis
    if isempty(spectraMatrix) || ~isnumeric(spectraMatrix) || ndims(spectraMatrix) ~= 2 || size(spectraMatrix,1) == 0 || size(spectraMatrix,2) ~= num_wavenumber_points
        % This probe's spectra were likely skipped in the exploratory script, so it won't match T2/Q value counts
        continue;
    end
    X_train_for_removal = [X_train_for_removal; spectraMatrix];
    temp_row_counter = temp_row_counter + size(spectraMatrix,1);
end

if size(X_train_for_removal,1) ~= length(T2_values_all)
    error(['Mismatch in number of spectra. Reconstructed X_train_for_removal has %d spectra, ' ...
           'while loaded T2_values_all has %d values. \nEnsure dataTableTrain input here matches ' ...
           'the one used in the exploratory script and that CombinedSpectra contains the correct preprocessed data.'], ...
           size(X_train_for_removal,1), length(T2_values_all));
end
fprintf('Successfully mapped and reconstructed X_train_for_removal (%d spectra) for outlier processing.\n', size(X_train_for_removal,1));

%% --- 2. Apply Consensus (T2 AND Q) Outlier Removal Strategy ---
fprintf('\n--- 2. Applying Consensus (T2 AND Q) Outlier Removal ---\n');

flag_T2_all = (T2_values_all > T2_threshold);
flag_Q_all  = (Q_values_all > Q_threshold);

% Consensus Outlier Strategy
consensus_outlier_indices_logical = flag_T2_all & flag_Q_all;
num_consensus_outliers = sum(consensus_outlier_indices_logical);
fprintf('%d consensus outliers (T2 AND Q) identified for removal.\n', num_consensus_outliers);

good_indices_logical = ~consensus_outlier_indices_logical;

%% --- 3. Create Cleaned Flat Dataset for Machine Learning ---
fprintf('\n--- 3. Creating Cleaned Flat Dataset (Consensus Strategy) ---\n');

X_train_no_outliers_AND = X_train_for_removal(good_indices_logical, :);
y_train_no_outliers_AND_cat = y_categorical_map(good_indices_logical); % Categorical labels
y_train_no_outliers_AND_num = y_numeric_map(good_indices_logical);     % Numeric labels
Patient_ID_train_no_outliers_AND = Patient_ID_map(good_indices_logical);
Original_ProbeRowIndices_no_outliers_AND = Original_ProbeRowIndices_map(good_indices_logical);
Original_SpectrumIndexInProbe_no_outliers_AND = Original_SpectrumIndexInProbe_map(good_indices_logical);

fprintf('Size of cleaned X_train_no_outliers_AND: %d spectra x %d features.\n', ...
      size(X_train_no_outliers_AND, 1), size(X_train_no_outliers_AND, 2));

cleanedFlatDatasetFilename = fullfile(dataDir, sprintf('%s_training_set_no_outliers_T2andQ.mat', P.datePrefix));
save(cleanedFlatDatasetFilename, ...
     'X_train_no_outliers_AND', 'y_train_no_outliers_AND_cat', 'y_train_no_outliers_AND_num', ...
     'Patient_ID_train_no_outliers_AND', ...
     'Original_ProbeRowIndices_no_outliers_AND', ...
     'Original_SpectrumIndexInProbe_no_outliers_AND', ...
     'wavenumbers_roi', ...
     'expData', ... % Save the loaded exploratoryOutlierData struct for traceability of thresholds etc.
     '-v7.3');
fprintf('Cleaned flat training dataset (T2 AND Q strategy) saved to: %s\n', cleanedFlatDatasetFilename);

%% --- 4. Create Cleaned dataTableTrain with Consensus Outlier Details ---
fprintf('\n--- 4. Creating Cleaned dataTableTrain (Consensus Strategy) ---\n');
dataTableTrain_cleaned_consensus = dataTableTrain_original; % Start with a copy of the original structure
numProbes = height(dataTableTrain_cleaned_consensus);

% Initialize new columns
dataTableTrain_cleaned_consensus.CombinedSpectra_ConsensusCleaned = cell(numProbes, 1);
dataTableTrain_cleaned_consensus.OutlierSpectra_Consensus = cell(numProbes, 1);
dataTableTrain_cleaned_consensus.OutlierIndicesInSample_Consensus = cell(numProbes, 1);
dataTableTrain_cleaned_consensus.NumOriginalSpectraInProbe = zeros(numProbes,1);
dataTableTrain_cleaned_consensus.NumOutliers_Consensus = zeros(numProbes,1);
dataTableTrain_cleaned_consensus.NumSpectra_ConsensusCleaned = zeros(numProbes,1);

for i = 1:numProbes
    original_probe_spectra = dataTableTrain_original.CombinedSpectra{i}; % These are the preprocessed spectra
    dataTableTrain_cleaned_consensus.NumOriginalSpectraInProbe(i) = size(original_probe_spectra,1);

    if isempty(original_probe_spectra) || dataTableTrain_cleaned_consensus.NumOriginalSpectraInProbe(i) == 0
        dataTableTrain_cleaned_consensus.CombinedSpectra_ConsensusCleaned{i} = zeros(0, num_wavenumber_points);
        dataTableTrain_cleaned_consensus.OutlierSpectra_Consensus{i} = zeros(0, num_wavenumber_points);
        dataTableTrain_cleaned_consensus.OutlierIndicesInSample_Consensus{i} = [];
        continue;
    end

    % Find which global indices (from T2_values_all) correspond to this probe
    global_indices_this_probe = find(Original_ProbeRowIndices_map == i);

    if isempty(global_indices_this_probe) || length(global_indices_this_probe) ~= size(original_probe_spectra,1)
         warning('Probe %d (Diss_ID: %s): Mismatch between spectra count in dataTableTrain_original and mapping. Skipping consensus cleaning for this probe.', i, dataTableTrain_original.Diss_ID{i});
         dataTableTrain_cleaned_consensus.CombinedSpectra_ConsensusCleaned{i} = original_probe_spectra; % Keep all if mapping failed
         dataTableTrain_cleaned_consensus.OutlierSpectra_Consensus{i} = zeros(0, num_wavenumber_points);
         dataTableTrain_cleaned_consensus.OutlierIndicesInSample_Consensus{i} = [];
         dataTableTrain_cleaned_consensus.NumSpectra_ConsensusCleaned(i) = size(original_probe_spectra,1);
         continue;
    end
    
    consensus_flags_this_probe = consensus_outlier_indices_logical(global_indices_this_probe);
    
    internal_indices_original_this_probe = (1:size(original_probe_spectra,1))';
    
    dataTableTrain_cleaned_consensus.CombinedSpectra_ConsensusCleaned{i} = original_probe_spectra(~consensus_flags_this_probe, :);
    dataTableTrain_cleaned_consensus.OutlierSpectra_Consensus{i} = original_probe_spectra(consensus_flags_this_probe, :);
    dataTableTrain_cleaned_consensus.OutlierIndicesInSample_Consensus{i} = internal_indices_original_this_probe(consensus_flags_this_probe);
    dataTableTrain_cleaned_consensus.NumOutliers_Consensus(i) = sum(consensus_flags_this_probe);
    dataTableTrain_cleaned_consensus.NumSpectra_ConsensusCleaned(i) = size(dataTableTrain_cleaned_consensus.CombinedSpectra_ConsensusCleaned{i},1);
end

cleanedTableFilename_mat = fullfile(resultsDir, sprintf('%s_dataTableTrain_Cleaned_Consensus_T2andQ.mat', P.datePrefix));
save(cleanedTableFilename_mat, 'dataTableTrain_cleaned_consensus');
fprintf('Cleaned dataTableTrain (Consensus T2 AND Q strategy) saved to: %s\n', cleanedTableFilename_mat);

% Save overview for Excel
overview_excel_consensus = dataTableTrain_cleaned_consensus;
overview_excel_consensus.OutlierIndicesInSample_Consensus_str = cellfun(@(x) num2str(x(:)'), overview_excel_consensus.OutlierIndicesInSample_Consensus, 'UniformOutput', false);
colsToExport_excel = {'Diss_ID', 'Patient_ID', 'WHO_Grade', 'NumOriginalSpectraInProbe', ...
                      'NumSpectra_ConsensusCleaned', 'NumOutliers_Consensus', ...
                      'OutlierIndicesInSample_Consensus_str'};
varsToExportFinal_excel = intersect(colsToExport_excel, overview_excel_consensus.Properties.VariableNames, 'stable');
overviewFilename_xlsx_consensus = fullfile(resultsDir, sprintf('%s_dataTableTrain_Cleaned_Consensus_T2andQ_Overview.xlsx', P.datePrefix));
try
    writetable(overview_excel_consensus(:, varsToExportFinal_excel), overviewFilename_xlsx_consensus);
    fprintf('Overview of the consensus-cleaned table saved as Excel: %s\n', overviewFilename_xlsx_consensus);
catch ME_excel_save_consensus
    fprintf('Could not save Excel overview of consensus-cleaned table: %s\n', ME_excel_save_consensus.message);
end

%% --- 5. Save List of Removed Consensus Outliers ---
fprintf('\n--- 5. Saving List of Removed Consensus Outliers ---\n');
if num_consensus_outliers > 0
    consensus_outliers_table = table(...
        Patient_ID_map(consensus_outlier_indices_logical), ...
        Original_ProbeRowIndices_map(consensus_outlier_indices_logical), ...
        Original_SpectrumIndexInProbe_map(consensus_outlier_indices_logical), ...
        T2_values_all(consensus_outlier_indices_logical), ...
        Q_values_all(consensus_outlier_indices_logical), ...
        'VariableNames', {'Patient_ID', 'Original_Probe_Row_Index', 'Original_Spectrum_Index_In_Probe', 'T2_Value', 'Q_Value'});
    
    removedListFilename_csv = fullfile(resultsDir, sprintf('%s_PCA_T2andQ_Consensus_RemovedOutlierList.csv', P.datePrefix));
    writetable(consensus_outliers_table, removedListFilename_csv);
    fprintf('List of %d removed consensus outliers saved to: %s\n', num_consensus_outliers, removedListFilename_csv);
else
    fprintf('No consensus outliers were removed, so no list to save.\n');
end

fprintf('\n--- Consensus (T2 AND Q) Outlier Removal Script Finished ---\n');