% run_visualize_project_results.m
% Main script to load project results and generate a suite of visualizations.
%
% IMPORTANT:
% 1. Adjust 'resultsBaseDir' to point to your main results folder.
% 2. Update the 'classificationResultsFile', 'probeLevelResultsFile',
%    'featureImportanceFile', and 'commonDataFile' to your specific .mat
%    filenames or implement logic to find the latest/correct files.
% 3. CRITICAL: Inside the 'Data Loading' section, ensure the variable names
%    (e.g., loadedClassificationData.trueTestLabels, loadedFeatureData.modelCoefficients)
%    EXACTLY match how they are stored within your .mat files.

% ------------------------------------------------------------------------
% 1. Initialization
% ------------------------------------------------------------------------
clearvars;  % Clear workspace variables
close all;  % Close all existing figures
clc;        % Clear command window
fprintf('============================================================\n');
fprintf('Starting Visualization of Project Results (%s)\n', datestr(now));
fprintf('============================================================\n\n');

% --- Add necessary paths (optional) ---
% If your helper functions are in separate .m files in a subdirectory:
% addpath(genpath('./plotting_functions'));
% If your results are in a specific, non-relative path:
% addpath('D:/Path/To/My/Dissertation/Results');


% ------------------------------------------------------------------------
% 2. Configuration
% ------------------------------------------------------------------------
fprintf('--- Configuration ---\n');

% --- Define base directory for results ---
% !!! ADJUST THIS PATH to your actual main results folder !!!
resultsBaseDir = './results_output/'; % Example: 'D:/Dissertation/ProjectOutput/Results/'
fprintf('Results Base Directory: %s\n', resultsBaseDir);

% --- Define specific result file names ---
% Option 1: Manually specify filenames.
% Replace these with your actual filenames. Consider using a consistent naming
% scheme or a helper function to find the latest relevant files.
% Example placeholder filenames - YOU MUST UPDATE THESE
classificationResultsFile   = fullfile(resultsBaseDir, 'final_model_test_set_predictions.mat');
probeLevelResultsFile       = fullfile(resultsBaseDir, 'final_model_probe_level_aggregation.mat');
featureImportanceFile       = fullfile(resultsBaseDir, 'final_model_feature_importance.mat');
commonDataFile              = fullfile(resultsBaseDir, 'common_dataset_info.mat'); % e.g., for wavenumbers

fprintf('Expected classification results file: %s\n', classificationResultsFile);
fprintf('Expected probe-level results file: %s\n', probeLevelResultsFile);
fprintf('Expected feature importance file: %s\n', featureImportanceFile);
fprintf('Expected common data file: %s\n\n', commonDataFile);

% --- Define class information ---
classNames         = {'WHO I', 'WHO III'}; % How class names should appear in plots
positiveClassName  = 'WHO III';            % The string name of your positive class
positiveClassLabel = 1;                    % The numeric/logical label used for the positive class in your data
negativeClassLabel = 0;                    % The numeric/logical label used for the negative class

% --- Plotting Toggles ---
% Set to true to generate the plot, false to skip.
doPlotConfusionMatrix        = true;
doPlotRocDet                 = true;
doPlotProbabilityDistribution = true;
doPlotFeatureImportance      = true;

fprintf('Plotting toggles set.\n\n');

% ------------------------------------------------------------------------
% 3. Data Loading
% ------------------------------------------------------------------------
fprintf('--- Loading Data ---\n');

% --- Load classification results (for Confusion Matrix, ROC/DET) ---
if doPlotConfusionMatrix || doPlotRocDet
    try
        fprintf('Attempting to load classification results from: %s\n', classificationResultsFile);
        if exist(classificationResultsFile, 'file')
            loadedClassificationData = load(classificationResultsFile);
            % !!! ADAPT THESE VARIABLE NAMES to your .mat file structure !!!
            % Expected fields in loadedClassificationData (examples):
            % .trueTestLabels      (vector of true labels for the test set, e.g., [0; 1; 0; ...])
            % .predictedTestLabels (vector of predicted labels for the test set)
            % .predictedTestScores (vector of scores/probabilities for the positive class)
            %
            % Example check (uncomment and adapt to verify):
            % if ~isfield(loadedClassificationData, 'trueTestLabels') || ~isfield(loadedClassificationData, 'predictedTestLabels') || ~isfield(loadedClassificationData, 'predictedTestScores')
            %     error('One or more expected classification variables not found in %s', classificationResultsFile);
            % end
            fprintf('Successfully loaded classification results.\n');
        else
            warning('Classification results file not found: %s', classificationResultsFile);
            loadedClassificationData = []; % Ensure variable exists to prevent later errors
        end
    catch ME
        warning('Error loading classification results from %s: %s', classificationResultsFile, ME.message);
        loadedClassificationData = [];
    end
else
    fprintf('Skipping loading of classification results data as plots are disabled.\n');
    loadedClassificationData = []; % Ensure variable exists
end
fprintf('\n');

% --- Load probe-level aggregated results (for Probability Distribution Plot) ---
if doPlotProbabilityDistribution
    try
        fprintf('Attempting to load probe-level results from: %s\n', probeLevelResultsFile);
        if exist(probeLevelResultsFile, 'file')
            loadedProbeData = load(probeLevelResultsFile);
            % !!! ADAPT THESE VARIABLE NAMES to your .mat file structure !!!
            % Expected fields in loadedProbeData (examples):
            % .probeTrueLabels                     (vector of true labels for each probe)
            % .probeMeanProbabilities_PositiveClass (vector of mean predicted probs for the positive class per probe)
            %
            % Example check:
            % if ~isfield(loadedProbeData, 'probeTrueLabels') || ~isfield(loadedProbeData, 'probeMeanProbabilities_PositiveClass')
            %     error('One or more expected probe-level variables not found in %s', probeLevelResultsFile);
            % end
            fprintf('Successfully loaded probe-level results.\n');
        else
            warning('Probe-level results file not found: %s', probeLevelResultsFile);
            loadedProbeData = [];
        end
    catch ME
        warning('Error loading probe-level results from %s: %s', probeLevelResultsFile, ME.message);
        loadedProbeData = [];
    end
else
    fprintf('Skipping loading of probe-level results data as plot is disabled.\n');
    loadedProbeData = [];
end
fprintf('\n');

% --- Load feature importance data and common data (wavenumbers) ---
if doPlotFeatureImportance
    try
        fprintf('Attempting to load feature importance data from: %s\n', featureImportanceFile);
        if exist(featureImportanceFile, 'file')
            loadedFeatureData = load(featureImportanceFile);
            % !!! ADAPT THESE VARIABLE NAMES to your .mat file structure !!!
            % Expected fields in loadedFeatureData (examples):
            % .modelCoefficients                  (vector of coefficients from your model)
            % .meanDifferenceSpectrum_PosVsNeg (optional: mean spectrum of positive class - mean spectrum of negative class)
            % .mRMR_indices                       (optional: indices of features selected by mRMR)
            %
            % Example check:
            % if ~isfield(loadedFeatureData, 'modelCoefficients')
            %     error('Expected modelCoefficients not found in %s', featureImportanceFile);
            % end
            fprintf('Successfully loaded feature importance data.\n');
        else
            warning('Feature importance data file not found: %s', featureImportanceFile);
            loadedFeatureData = [];
        end

        fprintf('Attempting to load common spectral data (wavenumbers) from: %s\n', commonDataFile);
        if exist(commonDataFile, 'file')
            loadedCommonData = load(commonDataFile);
            % !!! ADAPT THIS VARIABLE NAME to your .mat file structure !!!
            % Expected field in loadedCommonData (example):
            % .wavenumbers_roi (vector of wavenumber values)
            %
            % Example check:
            % if ~isfield(loadedCommonData, 'wavenumbers_roi')
            %    error('Expected wavenumbers_roi not found in %s', commonDataFile);
            % end
            fprintf('Successfully loaded common spectral data.\n');
        else
            warning('Common spectral data file not found: %s', commonDataFile);
            loadedCommonData = [];
        end
    catch ME
        warning('Error loading feature importance or common data: %s', ME.message);
        loadedFeatureData = []; loadedCommonData = [];
    end
else
    fprintf('Skipping loading of feature importance/common data as plot is disabled.\n');
    loadedFeatureData = []; loadedCommonData = [];
end
fprintf('\n');


% ------------------------------------------------------------------------
% 4. Data Preparation & Calling Visualization Functions
% ------------------------------------------------------------------------
fprintf('--- Generating Visualizations ---\n');

% --- 4.1 Confusion Matrix ---
if doPlotConfusionMatrix && ~isempty(loadedClassificationData) && isfield(loadedClassificationData, 'trueTestLabels') && isfield(loadedClassificationData, 'predictedTestLabels')
    fprintf('Preparing and plotting Confusion Matrix...\n');
    try
        % Ensure labels are categorical for confusionchart with specified class names.
        % This assumes trueTestLabels/predictedTestLabels are numeric (e.g., 0 and 1).
        % Adjust if your labels are already categorical or different numeric values.
        trueL_cat = categorical(loadedClassificationData.trueTestLabels, [negativeClassLabel, positiveClassLabel], classNames);
        predL_cat = categorical(loadedClassificationData.predictedTestLabels, [negativeClassLabel, positiveClassLabel], classNames);

        plotConfusionMatrix(trueL_cat, predL_cat, classNames, ...
            ['Confusion Matrix: Final Model (Test Set) - ', datestr(now, 'yyyy-mm-dd')]);
    catch ME
        warning('Failed to generate Confusion Matrix: %s\nConsider checking label formats and data consistency.', ME.message);
    end
    fprintf('\n');
else
    fprintf('Skipping Confusion Matrix plot (data missing or plot disabled).\n\n');
end

% --- 4.2 ROC and DET Curves ---
if doPlotRocDet && ~isempty(loadedClassificationData) && isfield(loadedClassificationData, 'trueTestLabels') && isfield(loadedClassificationData, 'predictedTestScores')
    fprintf('Preparing and plotting ROC/DET Curves...\n');
    try
        % perfcurve can take numeric or categorical true labels.
        % If trueTestLabels are numeric [0,1], positiveClassLabel (e.g., 1) is used.
        % If trueTestLabels are categorical, positiveClassName (e.g., 'WHO III') is used.
        % Ensure consistency here.
        localTrueLabels = loadedClassificationData.trueTestLabels;
        localScores = loadedClassificationData.predictedTestScores;
        localPositiveClassIdentifier = positiveClassLabel; % Assuming numeric labels

        % If your true labels are categorical in the .mat file:
        % localTrueLabels = loadedClassificationData.trueTestLabels_categorical; % Example
        % localPositiveClassIdentifier = positiveClassName; % Use string name

        plotRocAndDetCurves(localTrueLabels, ...
                            localScores, ...
                            localPositiveClassIdentifier, ...
                            ['ROC: Final Model (Test Set) - ', datestr(now, 'yyyy-mm-dd')], ...
                            ['DET: Final Model (Test Set) - ', datestr(now, 'yyyy-mm-dd')], ...
                            true); % true for normal deviate scale on DET
    catch ME
        warning('Failed to generate ROC/DET Curves: %s\nConsider checking label formats and score vector.', ME.message);
    end
    fprintf('\n');
else
    fprintf('Skipping ROC/DET Curves plot (data missing or plot disabled).\n\n');
end

% --- 4.3 Probability Distribution Plot ---
if doPlotProbabilityDistribution && ~isempty(loadedProbeData) && isfield(loadedProbeData, 'probeTrueLabels') && isfield(loadedProbeData, 'probeMeanProbabilities_PositiveClass')
    fprintf('Preparing and plotting Probability Distribution Plot...\n');
    try
        plotProbabilityDistribution(loadedProbeData.probeMeanProbabilities_PositiveClass, ...
                                    loadedProbeData.probeTrueLabels, ...
                                    positiveClassName, ... % For y-axis label text
                                    ['Probe Probabilities (Boxplot) - ', datestr(now, 'yyyy-mm-dd')], ...
                                    ['Probe Probabilities (Dotplot) - ', datestr(now, 'yyyy-mm-dd')]);
    catch ME
        warning('Failed to generate Probability Distribution Plot: %s', ME.message);
    end
    fprintf('\n');
else
    fprintf('Skipping Probability Distribution Plot (data missing or plot disabled).\n\n');
end

% --- 4.4 Feature Importance Spectrum ---
if doPlotFeatureImportance && ~isempty(loadedFeatureData) && isfield(loadedFeatureData, 'modelCoefficients') && ~isempty(loadedCommonData) && isfield(loadedCommonData, 'wavenumbers_roi')
    fprintf('Preparing and plotting Feature Importance Spectrum...\n');
    try
        featImpOptions = struct(); % Initialize options struct
        if isfield(loadedFeatureData, 'meanDifferenceSpectrum_PosVsNeg')
           featImpOptions.meanDifferenceSpectrum = loadedFeatureData.meanDifferenceSpectrum_PosVsNeg;
        end
        if isfield(loadedFeatureData, 'mRMR_indices')
           featImpOptions.mRMR_indices = loadedFeatureData.mRMR_indices;
        end
        % You can customize peak detection parameters here if defaults are not suitable
        % featImpOptions.peakThresholdFactor = 0.3;
        % featImpOptions.minPeakDistWavenumbers = 15;

        plotFeatureImportanceSpectrum(loadedCommonData.wavenumbers_roi, ...
                                      loadedFeatureData.modelCoefficients, ...
                                      ['Feature Importance: Final Model - ', datestr(now, 'yyyy-mm-dd')], ...
                                      featImpOptions);
    catch ME
        warning('Failed to generate Feature Importance Spectrum: %s', ME.message);
    end
    fprintf('\n');
else
    fprintf('Skipping Feature Importance Spectrum plot (data missing or plot disabled).\n\n');
end

fprintf('============================================================\n');
fprintf('Visualization script finished (%s)\n', datestr(now));
fprintf('============================================================\n');

% ------------------------------------------------------------------------
% 5. Helper Function Definitions
%    (These can also be in separate .m files on the MATLAB path)
% ------------------------------------------------------------------------

function fh_cm = plotConfusionMatrix(trueLabels, predictedLabels, classNamesArg, titleStr)
% plotConfusionMatrix - Displays a confusion matrix.
    if nargin < 4 || isempty(titleStr)
        titleStr = 'Confusion Matrix';
    end

    fh_cm = figure('Name', titleStr, 'NumberTitle', 'off');
    try
        cm = confusionchart(trueLabels, predictedLabels);
        cm.Title = titleStr;
        if nargin >= 3 && ~isempty(classNamesArg)
            cm.ClassNames = classNamesArg;
        end
        % cm.ColumnSummary = 'column-normalized'; % Optional: Precision
        % cm.RowSummary = 'row-normalized';     % Optional: Recall
        fprintf('Confusion matrix ''%s'' plotted.\n', titleStr);
    catch ME
        fprintf('Error plotting confusion matrix: %s\n', ME.message);
        if ishandle(fh_cm); close(fh_cm); fh_cm = []; end % Close figure if error
    end
end

function fh_roc_det = plotRocAndDetCurves(trueLabels, scores, positiveClassIdentifier, titleRocStr, titleDetStr, useNormalDeviateScaleDet)
% plotRocAndDetCurves - Plots ROC and DET curves side-by-side.
    if nargin < 4 || isempty(titleRocStr)
        titleRocStr = 'ROC Curve';
    end
    if nargin < 5 || isempty(titleDetStr)
        titleDetStr = 'DET Curve';
    end
    if nargin < 6 || isempty(useNormalDeviateScaleDet)
        useNormalDeviateScaleDet = false;
    end

    fh_roc_det = figure('Name', [titleRocStr, ' & ', titleDetStr], 'NumberTitle', 'off');
    try
        [Xroc, Yroc, ~, AUCroc] = perfcurve(trueLabels, scores, positiveClassIdentifier);
        [Xdet_fpr, Ydet_fnr] = perfcurve(trueLabels, scores, positiveClassIdentifier, 'XCrit', 'fpr', 'YCrit', 'fnr');

        tiledlayout(1, 2, 'Padding', 'compact', 'TileSpacing', 'compact');

        ax_roc = nexttile;
        plot(ax_roc, Xroc, Yroc, 'LineWidth', 1.5);
        hold(ax_roc, 'on'); plot(ax_roc, [0 1], [0 1], 'k--'); hold(ax_roc, 'off');
        xlabel(ax_roc, 'False Positive Rate (FPR)'); ylabel(ax_roc, 'True Positive Rate (TPR)');
        title(ax_roc, sprintf('%s (AUC = %.3f)', titleRocStr, AUCroc));
        grid(ax_roc, 'on'); axis(ax_roc, [0 1 0 1]);

        ax_det = nexttile;
        if useNormalDeviateScaleDet
            epsilon = 1e-7;
            Xdet_fpr_norm = norminv(max(epsilon, min(1-epsilon, Xdet_fpr)));
            Ydet_fnr_norm = norminv(max(epsilon, min(1-epsilon, Ydet_fnr)));
            plot(ax_det, Xdet_fpr_norm, Ydet_fnr_norm, 'LineWidth', 1.5);
            xlabel(ax_det, 'FPR (Normal Deviate Scale)'); ylabel(ax_det, 'FNR (Normal Deviate Scale)');
            title(ax_det, [titleDetStr, ' (Normal Deviate)']);
            prob_ticks = [0.001, 0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.95, 0.98, 0.99, 0.999];
            norm_ticks = norminv(prob_ticks);
            set(ax_det, 'XTick', norm_ticks(norm_ticks >= min(Xdet_fpr_norm)-eps & norm_ticks <= max(Xdet_fpr_norm)+eps));
            set(ax_det, 'YTick', norm_ticks(norm_ticks >= min(Ydet_fnr_norm)-eps & norm_ticks <= max(Ydet_fnr_norm)+eps));
            xticklabels(ax_det, sprintfc('%.3g', prob_ticks(ismembertol(norm_ticks, get(ax_det,'XTick')))));
            yticklabels(ax_det, sprintfc('%.3g', prob_ticks(ismembertol(norm_ticks, get(ax_det,'YTick')))));
        else
            plot(ax_det, Xdet_fpr, Ydet_fnr, 'LineWidth', 1.5);
            xlabel(ax_det, 'False Positive Rate (FPR)'); ylabel(ax_det, 'False Negative Rate (FNR)');
            title(ax_det, titleDetStr); axis(ax_det, [0 1 0 1]);
        end
        grid(ax_det, 'on');
        fprintf('ROC and DET curves ''%s'' & ''%s'' plotted.\n', titleRocStr, titleDetStr);
    catch ME
        fprintf('Error plotting ROC/DET curves: %s\n', ME.message);
        if ishandle(fh_roc_det); close(fh_roc_det); fh_roc_det = []; end
    end
end

function fh_prob_dist = plotProbabilityDistribution(probeLevelProbabilities, trueProbeClasses, positiveClassNameText, titleBoxStr, titleDotStr)
% plotProbabilityDistribution - Displays boxplot and dotplot of probe-level probabilities.
    if nargin < 4 || isempty(titleBoxStr)
        titleBoxStr = 'Boxplot of Probe Probabilities';
    end
    if nargin < 5 || isempty(titleDotStr)
        titleDotStr = 'Dotplot of Probe Probabilities';
    end

    fh_prob_dist = figure('Name', [titleBoxStr, ' & ', titleDotStr], 'NumberTitle', 'off');
    try
        yLabelStr = sprintf('Predicted Probability for %s', string(positiveClassNameText));
        tiledlayout(1, 2, 'Padding', 'compact', 'TileSpacing', 'compact');

        ax_box = nexttile;
        boxplot(ax_box, probeLevelProbabilities, trueProbeClasses, 'Whisker', 1.5); % 'Labels' auto from unique trueProbeClasses
        ylabel(ax_box, yLabelStr); title(ax_box, titleBoxStr);
        grid(ax_box, 'on'); ylim(ax_box, [0 1]);

        ax_dot = nexttile;
        if isnumeric(trueProbeClasses) || islogical(trueProbeClasses)
            cats = unique(trueProbeClasses);
            catNames = arrayfun(@num2str, cats, 'UniformOutput', false); % Basic numeric to string for labels
            % For WHO I/III, you might want specific names:
            % idx_neg = find(cats == 0); idx_pos = find(cats == 1); % Assuming 0 and 1
            % if ~isempty(idx_neg); catNames{idx_neg} = 'WHO I'; end
            % if ~isempty(idx_pos); catNames{idx_pos} = 'WHO III'; end
            trueProbeClassesCat = categorical(trueProbeClasses, cats, catNames, 'Ordinal', false);
        else
            trueProbeClassesCat = categorical(trueProbeClasses); % Ensure it's categorical
        end
        
        classCats = categories(trueProbeClassesCat);
        numCats = length(classCats);
        colors = lines(numCats);

        for i = 1:numCats
            isCurrentClass = (trueProbeClassesCat == classCats{i});
            y_values = probeLevelProbabilities(isCurrentClass);
            x_position = i;
            jitter_amount = 0.15; % Adjust for spread
            x_jittered = x_position + jitter_amount * (rand(size(y_values)) - 0.5);
            scatter(ax_dot, x_jittered, y_values, 36, 'filled', 'MarkerFaceColor', colors(i,:), 'MarkerFaceAlpha', 0.6);
            hold(ax_dot, 'on');
        end
        hold(ax_dot, 'off');
        xticks(ax_dot, 1:numCats); xticklabels(ax_dot, classCats);
        ylabel(ax_dot, yLabelStr); title(ax_dot, titleDotStr);
        grid(ax_dot, 'on'); ylim(ax_dot, [0 1]);
        fprintf('Probability distribution plots ''%s'' & ''%s'' created.\n', titleBoxStr, titleDotStr);
    catch ME
        fprintf('Error plotting probability distributions: %s\n', ME.message);
        if ishandle(fh_prob_dist); close(fh_prob_dist); fh_prob_dist = []; end
    end
end

function fh_feat_imp = plotFeatureImportanceSpectrum(wavenumbers, coefficients, titleStr, options)
% plotFeatureImportanceSpectrum - Plots the feature importance spectrum.
    if nargin < 3 || isempty(titleStr)
        titleStr = 'Feature Importance Spectrum';
    end
    if nargin < 4; options = struct(); end
    if ~isfield(options, 'peakThresholdFactor'); options.peakThresholdFactor = 0.4; end
    if ~isfield(options, 'minPeakDistWavenumbers'); options.minPeakDistWavenumbers = 20; end

    fh_feat_imp = figure('Name', titleStr, 'NumberTitle', 'off');
    try
        plot(wavenumbers, coefficients, 'b', 'LineWidth', 1.5);
        hold on;
        legendEntries = {'Model Coefficients'};

        if isfield(options, 'meanDifferenceSpectrum') && ~isempty(options.meanDifferenceSpectrum)
            diffSpec = options.meanDifferenceSpectrum;
            if max(abs(diffSpec)) > 1e-7
                scaledDiffSpec = diffSpec * (max(abs(coefficients)) / max(abs(diffSpec))) * 0.3;
                plot(wavenumbers, scaledDiffSpec, '--', 'LineWidth', 1, 'Color', [0.8500 0.3250 0.0980 0.7]);
                legendEntries{end+1} = 'Scaled Difference Spectrum';
            end
        end

        absCoeffs = abs(coefficients);
        peakThreshold = options.peakThresholdFactor * max(absCoeffs);
        [~, peak_wavenumbers_locs] = findpeaks(absCoeffs, wavenumbers, 'MinPeakHeight', peakThreshold, 'MinPeakDistance', options.minPeakDistWavenumbers);

        if ~isempty(peak_wavenumbers_locs)
            coeffs_at_peaks = interp1(wavenumbers, coefficients, peak_wavenumbers_locs, 'nearest');
            plot(peak_wavenumbers_locs, coeffs_at_peaks, 'kv', 'MarkerFaceColor', 'k', 'MarkerSize', 7);
            legendEntries{end+1} = 'Important Peaks';
        end

        if isfield(options, 'mRMR_indices') && ~isempty(options.mRMR_indices)
            mRMR_wavenumbers_vals = wavenumbers(options.mRMR_indices);
            for k_mRMR = 1:length(mRMR_wavenumbers_vals)
               xline(mRMR_wavenumbers_vals(k_mRMR), 'g--', 'LineWidth', 0.75, 'HandleVisibility','off'); % No individual legend entry
            end
             % Add a single representative plot for legend if mRMR features are plotted
            if ~isempty(mRMR_wavenumbers_vals)
                plot(NaN,NaN,'g--','LineWidth',0.75); % Dummy plot for legend
                legendEntries{end+1} = 'mRMR Features';
            end
        end

        xlabel('Wavenumber (cm^{-1})'); ylabel('Coefficient Value / Importance');
        title(titleStr);
        if numel(legendEntries) > 1 || (numel(legendEntries)==1 && ~strcmp(legendEntries{1},'Model Coefficients'))
             legend(legendEntries, 'Location', 'best', 'Interpreter', 'none');
        end
        grid on; ax = gca; ax.XDir = 'reverse';
        hold off;
        fprintf('Feature importance spectrum ''%s'' plotted.\n', titleStr);
    catch ME
        fprintf('Error plotting feature importance: %s\n', ME.message);
        if ishandle(fh_feat_imp); close(fh_feat_imp); fh_feat_imp = []; end
    end
end